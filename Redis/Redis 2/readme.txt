Redis:
解决问题：
	mybatis的缓存的脏读问题
		不用多表，永远用单表。
		不要用缓存。

=======================================
解决方案：
	1：mybatis的缓存是对NameSpace而言，你维护当前数据，会刷新
	当前命名空间下的素有数据，而不会更新关联表的数据。

	核心：
		用Redis来替换Mybatids的二级缓存。更新当前NameSpace下的数据的时候，
		现在需要刷讯整个项目的所有数据。

	myBatis提供了一个Cache接口，来供你实现。

	重点：
		你用Redis来替换Mybatis二级缓存的步骤，你到底是什么写的。


为什么用它：
	1：Mybatis默认的缓存有脏读问题，缓存穿透
		原因：Mybatis的二级缓存是针对NameSpace而言，你的insert ,update ,delete
		只会引发当前NameSpace下的缓存清空，而不会清空相关的关联表。
		则会发生  A取B, 改B,此时 A里面的B还是老B.
			缓存击穿:
					缓存雪崩问题。为了解决这几个问题，才用

					Redis替换了MyBatis的二级缓存。
如何实现
2：缓存脏读
	用了Redis。自己写了一个类AppliactionHolder，实现了一个接口AppliactionContextAware。
	Spring容器在启动的时候，就会自动织入ApplicationContext。工具类：就能够向外界提供Spring容器内
	的对象了。

	MyBatis的xml <cache type="MyCache">  今后把缓存全部交给redis来处理。
	核心实现了如下几个方法：
		putObjcet
			塞到Redis里面
		getObject
			从Redis里面取
		delete
			从Redis里面删
		clear
			直接清空当前整个DB（绝无脏读的可能性）。

	同时，为了保证数据的准确性，方式多线程并发问题，还为了提供程序的速度。使用
	读写锁。
		pubObject是用了写锁。
		getObject是用了读锁。

3：缓存穿透
	数据库没有，缓存也没有。其实Mybatis3已经修复了。
		getObject();//如果取出来没有，我把null,也放缓存中了。
		我看到还有一种解决方案是布隆过滤器。但是当时时间有限，没有来得及用上。就简单粗暴的实现了。
		
4：缓存击穿
	缓存没有，数据库有。一条数据某个时间超时了，导致多个用户直接查库了。
	1：设置不同的失效时间
	2：读写锁。

5：缓存雪崩
	用随机数来设置超期时间。

	clear
			直接清空当前整个DB（绝无脏读的可能性）。

	给缓存分区：
		当时我也做的比较low。只分了2个区。
			新建立2个ConnectionFactory 两个RedisTemplate 一个选中0库，一个选中1库
			1：坚决不改的
				0库
			2：偶尔要改的
				1库
		clear:
			只更新1库。杜绝了雪崩。

=======================================
	缓存穿透
	缓存击穿:
	缓存雪崩
		clear的时候，connection.flushDb();
		删除整个数据库的缓存，那是雪崩的一塌糊涂。

		划分方法1：
		缓存【表】划分为2部分：
			1：基本坚决几乎不改的数据。
				省市区 权限树结构  学历  数据字典表
			2：经常需要修改和维护的数据。
				商品信息
		划分方法2：
			缓存区1：
				用户 权限  树 
			缓存区2：
				工资 考勤
			缓存区3：
				考试  改卷  
			

=======================================
锁：
	乐观锁
		delete update insert
	悲观锁
		select * from table where uid=1 for update
		select * from table for update no wait

	行锁
		select * form table where uid=1 for update
		select * form table
	
	表锁
		lock table st in share mode


	排他锁（写锁）
		一次只能有一个人加锁，其他人不能再加任何锁。自己可以改。
		lock table st in exclusive mode


	共享锁(读锁)
		所有人都可以加锁，所以人都只能加共享锁。所有人都只能看，不能摸。
	
	


=======================================
Mybatis关联的方式：
今后用哪个。

1：关联结果
	如果没有缓存，十分看重，当前代码的执行效率。是一种特殊情况，用这种。

	不存在1+n的问题，SQL语句只有一条。
	结构紊乱的，没有完全按照面向对象,字段描述出现在了多个xml中。
	多级嵌套很凌乱，不支持递归。
	select * from person a,car b where a.uid=b.uid
	

	<resultMap id="BaseResultMap" type="com.woniu.rediscache.entity.Person" >
	    <!--
	      WARNING - @mbggenerated
	      This element is automatically generated by MyBatis Generator, do not modify.
	      This element was generated on Fri Nov 15 09:45:21 CST 2019.
	    -->
	    <id column="pid" property="pid" jdbcType="INTEGER" />
	    <result column="name" property="name" jdbcType="VARCHAR" />
	    <collection property="cars" ofType="com.woniu.rediscache.entity.Car">
	      <id column="cid" property="cid"></id>
	      <result column="cname" property="cname"></result>
	      <collection property="cars" ofType="com.woniu.rediscache.entity.Car">
	      <id column="cid" property="cid"></id>
	      <result column="cname" property="cname"></result>
	      
	    </collection>
	    </collection>
	  </resultMap>

2：关联嵌套
	如果有缓存，用这种。
	即便没有缓存，级联太多，用这种。
	递归，只能用这种。

	会存在1+n的问题。SQL语句有1+n条。
	完全按照面向对象。字段描述只会出现在自己的xml.
	多级嵌套举清晰，支持递归。
	如果省市区，应该纳入二级缓存的管理。

	1：对象中set get
	2: <resultMap id="BaseResultMap" type="com.woniu.rediscache.entity.Person" >
	    <id column="pid" property="pid" jdbcType="INTEGER" />
	    <result column="name" property="name" jdbcType="VARCHAR"  />
	    <!--collection调用的是第二个mapper的方法-->
	    <collection property="cars" column="pid" select="com.woniu.rediscache.mapper.CarMapper.findByUid"></collection>
	  </resultMap>
	3：在另外一个mapper中，有这个select方法的实现
		CarMappper
		  <select id="findByUid" resultMap="BaseResultMap">
		    select * from car where pid=#{pid}
		  </select>
=================================================================================

=================================================================================
权限有几张表。那五张，这五张是什么关系。
围绕着五张表的一个SQL。
	根据用户id查询角色 查询权限

有如下数据表：
	tid  tname pid
	数据如下：
Tree
	treeid  treeName  treeurl   pid
	1       权限管理  /user/    0
	2       用户管理  /user1/   1
	3       字典管理  /user2/   1
	4       工资管理  /salary/  0
	5       人事管理  /salary/  0
	6       入职      /salary/  5
	7       今天入职  /salary/  6

用Mybatis实现对象间的包含关系：
	List<Tree<Tree<Tree>>>



  <resultMap id="BaseResultMap" type="com.woniu.rediscache.entity.Tree" >
    <id column="tid" property="pid" jdbcType="INTEGER" />
    <result column="tame" property="name" jdbcType="VARCHAR"  />
    <result column="pid" property="pid" jdbcType="Integer"  />
    <collection property="trees" column="tid" select="findByChild"></collection>
  </resultMap>

  <select id="findByChild" resultMap="BaseResultMap">
	select * from tree where pid=#{tid}
  </select>

  TreeMapper.findByChild(0);


权限管理
	用户管理
	字典管理
	部门管理
工资管理
	涨工资
	发工资
	绩效
	考核
人事管理
	入职
		今天入职
		明天入职

	离职
	培训